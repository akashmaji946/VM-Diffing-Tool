{% extends 'base.html' %}
{% block title %}Block Data Viewer{% endblock %}
{% block content %}
<h2>Block Data Viewer</h2>
<p style="color: #888; margin-bottom: 2rem;">View raw block data from a VM disk image</p>

<form id="blockDataForm">
  <div class="grid">
    <div>
      <label for="disk">Disk Path</label>
      <input type="text" id="disk" name="disk" placeholder="/path/to/disk.qcow2" required>
    </div>
    <div>
      <label for="block_number">Block Number</label>
      <input type="number" id="block_number" name="block_number" value="0" min="0" required>
    </div>
  </div>

  <div class="grid">
    <div>
      <label for="block_size">Block Size (bytes)</label>
      <input type="number" id="block_size" name="block_size" value="4096" min="512" step="512" required>
    </div>
    <div>
      <label>
        <input type="checkbox" id="format_bits" name="format" role="switch">
        Show as Bits (default: Hex)
      </label>
    </div>
  </div>

  <button type="submit" id="fetchBtn">Fetch Block Data</button>
</form>

<div id="loading" style="display: none; text-align: center; margin: 2rem 0;">
  <div aria-busy="true">Fetching block data...</div>
</div>

<div id="error" style="display: none; margin-top: 1rem;">
  <article style="background-color: rgba(255, 0, 0, 0.1); border-left: 4px solid #ff0000;">
    <p id="errorMessage"></p>
  </article>
</div>

<div id="results" style="display: none; margin-top: 2rem;">
  <h3>Block <span id="blockNumber"></span> Data</h3>
  
  <div style="margin-bottom: 1rem;">
    <strong>Disk:</strong> <span id="diskPath"></span><br>
    <strong>Block Size:</strong> <span id="resultBlockSize"></span> bytes<br>
    <strong>Format:</strong> <span id="resultFormat"></span>
  </div>

  <div id="tableContainer" style="background: #ffffff; padding: 0.5rem; border-radius: 4px; overflow-x: auto;">
    <table id="blockDataTable" style="width: 100%; border-collapse: collapse; font-family: 'Courier New', monospace; font-size: 0.85rem;">
      <thead>
        <tr>
          <th style="text-align:left; padding: 0.4rem; border-bottom: 1px solid #ccc; color:#000;">Offset</th>
          <th style="text-align:left; padding: 0.4rem; border-bottom: 1px solid #ccc; color:#000;">Data</th>
          <th style="text-align:left; padding: 0.4rem; border-bottom: 1px solid #ccc; color:#000;">ASCII</th>
        </tr>
      </thead>
      <tbody id="blockDataBody"></tbody>
    </table>
  </div>
  <!-- Legacy raw view (hidden) -->
  <div style="display:none">
    <pre id="blockDataDisplay"></pre>
  </div>
</div>

<script>
// Check URL parameters for pre-filled values
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.has('disk1')) {
  document.getElementById('disk').value = urlParams.get('disk1');
}
if (urlParams.has('block')) {
  document.getElementById('block_number').value = urlParams.get('block');
}
if (urlParams.has('size')) {
  document.getElementById('block_size').value = urlParams.get('size');
}

document.getElementById('blockDataForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  if (window.VMTS) window.VMTS.show();
  
  const disk = document.getElementById('disk').value;
  const block_number = parseInt(document.getElementById('block_number').value);
  const block_size = parseInt(document.getElementById('block_size').value);
  const format = document.getElementById('format_bits').checked ? 'bits' : 'hex';
  
  
  document.getElementById('error').style.display = 'none';
  document.getElementById('results').style.display = 'none';
  document.getElementById('fetchBtn').setAttribute('aria-busy', 'true');
  document.getElementById('fetchBtn').disabled = true;
  
  try {
    const response = await fetch('/api/block-data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        disk,
        block_number,
        block_size,
        format
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to fetch block data');
    }
    
    // Display metadata
    document.getElementById('blockNumber').textContent = block_number.toLocaleString();
    document.getElementById('diskPath').textContent = disk;
    document.getElementById('resultBlockSize').textContent = block_size.toLocaleString();
    document.getElementById('resultFormat').textContent = format.toUpperCase();
    
    // Format and display block data in a table
    const blockData = data[block_number.toString()] || '';
    renderBlockTable(blockData, format);
    
    document.getElementById('results').style.display = 'block';
    
  } catch (error) {
    document.getElementById('errorMessage').textContent = error.message;
    document.getElementById('error').style.display = 'block';
  } finally {
    if (window.VMTS) window.VMTS.hide();
    const btn = document.getElementById('fetchBtn');
    btn.removeAttribute('aria-busy');
    btn.disabled = false;
    btn.textContent = 'Fetch Block Data';
  }
});

function toAsciiFromHexBytes(hexBytes){
  const bytes = hexBytes.map(h => parseInt(h, 16));
  return bytes.map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');
}

function groupBits(bits, group=8){
  const out=[]; for(let i=0;i<bits.length;i+=group){ out.push(bits.slice(i,i+group)); } return out.join(' ');
}

function toAsciiFromBits(bits){
  // bits string length is multiple of 8
  let ascii = '';
  for (let i=0; i<bits.length; i+=8){
    const byte = bits.slice(i, i+8);
    if (byte.length < 8) break;
    const val = parseInt(byte, 2);
    ascii += (val >= 32 && val <= 126) ? String.fromCharCode(val) : '.';
  }
  return ascii;
}

function renderBlockTable(blockData, format){
  const tbody = document.getElementById('blockDataBody');
  tbody.innerHTML = '';
  if (!blockData){
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="3" style="padding:0.4rem; color:#ccc;">No data</td>';
    tbody.appendChild(tr);
    return;
  }
  if (format === 'hex'){
    // rows of 16 bytes
    const hexBytes = blockData.trim().split(/\s+/);
    for (let i=0;i<hexBytes.length;i+=16){
      const row = hexBytes.slice(i, i+16);
      const offset = i;
      const ascii = toAsciiFromHexBytes(row);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:0.4rem; color:#000;">${offset.toString(16).toUpperCase().padStart(4,'0')}</td>
        <td style="padding:0.4rem; color:#000;">${row.join(' ')}</td>
        <td style="padding:0.4rem; color:#000;">${ascii}</td>
      `;
      tbody.appendChild(tr);
    }
  } else {
    // rows of 64 bits (8 bytes)
    for (let i=0;i<blockData.length;i+=64){
      const rowBits = blockData.slice(i, i+64);
      const offsetBytes = Math.floor(i/8);
      const grouped = groupBits(rowBits);
      const ascii = toAsciiFromBits(rowBits);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:0.4rem; color:#000;">${offsetBytes.toString(16).toUpperCase().padStart(4,'0')}</td>
        <td style="padding:0.4rem; color:#000;">${grouped}</td>
        <td style="padding:0.4rem; color:#000;">${ascii}</td>
      `;
      tbody.appendChild(tr);
    }
  }
}
</script>

<style>
[data-theme="light"] #blockDataDisplay {
  background: #f5f5f5;
  color: #006400;
}
</style>
{% endblock %}
