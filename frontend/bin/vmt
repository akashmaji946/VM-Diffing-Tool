#!/usr/bin/env python3
"""
vmt CLI - VMT 0.1

Usage examples:
  vmt                 # prints welcome and help hint
  vmt -h              # full help
  vmt list --disk /path/to/disk.qcow2 --out listing.txt [--json listing.json] [--verbose]
  vmt meta --disk /path/to/disk.qcow2 [--verbose] [--json meta.json]
"""
import sys
import os
import argparse
import json

VERSION = "0.1"


def print_welcome():
    print(f"Welcome to VMT {VERSION} version")


def do_list(args: argparse.Namespace) -> int:
    disk = args.disk
    out = args.out
    json_out = args.json
    verbose = bool(args.verbose)

    try:
        import vmtool
        entries = vmtool.list_files_with_metadata(disk, verbose=verbose)
        # Write text output if requested
        if out:
            vmtool.write_files_with_metadata(entries, out)
            if verbose:
                print(f"Wrote {len(entries)} entries to: {out}")
            else:
                print(f"File listing saved to: {out}")

        # Optional JSON output with requested schema (delegated to backend)
        if json_out:
            json_data = vmtool.get_files_with_metadata_json(disk, verbose=verbose)
            with open(json_out, "w", encoding="utf-8") as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
            print(f"JSON listing saved to: {json_out}")

        if not out and not json_out:
            print("No output specified. Use --out for TEXT or --json for JSON.")
        return 0
    except Exception as e:
        print(f"Error: {e}")
        return 2

def do_meta(args: argparse.Namespace) -> int:
    disk = args.disk
    verbose = bool(args.verbose)
    json_out = args.json

    try:
        import vmtool
        meta = vmtool.get_meta_data(disk, verbose=verbose)
        if json_out:
            # Convert pybind dict to plain Python types via json dumps/loads
            with open(json_out, "w", encoding="utf-8") as f:
                json.dump(meta, f, indent=2)
            print(f"Metadata saved to: {json_out}")
        else:
            # Pretty print brief summary
            print("Totals:")
            print(f"  files: {meta['files_count']}")
            print(f"  dirs: {meta['dirs_count']}")
            print(f"  total_file_bytes: {meta['total_file_bytes']}")
            print(f"  total_dir_bytes: {meta['total_dir_bytes']}")
            print(f"  total_bytes: {meta['total_bytes']}")
            print("\nTop users by bytes:")
            for row in meta['per_user'][:5]:
                print(f"  {row['user']} (uid={row['uid']}): files={row['files']} dirs={row['dirs']} bytes={row['bytes']}")
            print("\nTop groups by bytes:")
            for row in meta['per_group'][:5]:
                print(f"  {row['group']} (gid={row['gid']}): files={row['files']} dirs={row['dirs']} bytes={row['bytes']}")
        return 0
    except Exception as e:
        print(f"Error: {e}")
        return 2


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="vmtool",
        description="VMT CLI - Utilities for diffing and inspecting VM disk images",
        add_help=True,
    )
    parser.add_argument(
        "-v", "--version", action="version", version=f"vmtool {VERSION}"
    )

    sub = parser.add_subparsers(dest="command", metavar="<command>")

    # list subcommand
    p_list = sub.add_parser(
        "list", help="List all files with metadata and write to a file"
    )
    p_list.add_argument("--disk", required=True, help="Path to qcow2/raw disk image")
    p_list.add_argument("--out", help="Output text file path")
    p_list.add_argument("--json", help="Optional path to save JSON listing with numbered keys")
    p_list.add_argument("--verbose", action="store_true", help="Verbose output")
    p_list.set_defaults(func=do_list)

    # meta subcommand
    p_meta = sub.add_parser(
        "meta", help="Get aggregated metadata for the disk image"
    )
    p_meta.add_argument("--disk", required=True, help="Path to qcow2/raw disk image")
    p_meta.add_argument("--verbose", action="store_true", help="Verbose output")
    p_meta.add_argument("--json", help="Optional path to save full JSON metadata")
    p_meta.set_defaults(func=do_meta)

    return parser


def main(argv: list[str]) -> int:
    if len(argv) == 0:
        print_welcome()
        print("Use -h for help.")
        return 0

    parser = build_parser()
    args = parser.parse_args(argv)

    if not getattr(args, "command", None):
        print_welcome()
        parser.print_help()
        return 0

    return args.func(args)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
